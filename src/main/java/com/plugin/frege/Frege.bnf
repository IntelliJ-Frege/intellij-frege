{
    parserClass="com.plugin.frege.parser.FregeParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Frege"
    psiImplClassSuffix="Impl"
    psiPackage="com.plugin.frege.psi"
    psiImplPackage="com.plugin.frege.psi.impl"

    elementTypeHolderClass="com.plugin.frege.psi.FregeTypes"
    elementTypeClass="com.plugin.frege.psi.FregeElementType"
    tokenTypeClass="com.plugin.frege.psi.FregeTokenType"

    psiImplUtilClass="com.plugin.frege.psi.impl.FregePsiImplUtil"
}

fregeFile ::= !<<eof>> program

private declRecover ::= !(VIRTUAL_END_DECL)

/* Operators */
fixity ::= infixRule PRECEDENCE lexOp+
    { pin=1 }

infixRule ::= INFIX | INFIXL | INFIXR
private opCharsCanUseAlone ::= (EXLAMATION_MARK | QUESTION_MARK | HASH | TILDA | PLUS |
            DOT | STAR | AT | COLON | DOUBLE_COLON | DASH |
            SLASH | BACK_SLASH | DOLLAR |
            RIGHT_ARROW | LEFT_ARROW | DOUBLE_RIGHT_ARROW | LESS | GREATER) // TODO %&^
private cannotAlone ::= EQUAL | VERT_BAR
symOp ::= opCharsCanUseAlone (opCharsCanUseAlone | cannotAlone)*
            | cannotAlone (opCharsCanUseAlone | cannotAlone)+

lexOp ::= WORD_OPERATOR | symOp

/* Unary operators */
unOp ::= EXLAMATION_MARK | QUESTION_MARK

/* Imported operators */
// Unary operators can not be qualified.
qLexOp ::= QUALIFIER? QUALIFIER? lexOp
qVarId ::= QUALIFIER? QUALIFIER? VARID
qConId ::= QUALIFIER? QUALIFIER? CONID

/* Literals */
literal ::= boolLiteral
            | numericLiteral
            | CHAR
            | STRING
            | REGEX
numericLiteral ::= integralLiteral
                    | floatLiteral
boolLiteral ::= TRUE | FALSE
integralLiteral ::= INTEGER
floatLiteral ::= FLOAT

/* Terms */
term ::= qVarId
         | qConId
         | literal
         | LEFT_PAREN expr RIGHT_PAREN
         | list
         | section
         | unit
         | tuple
         | qConId LEFT_BRACE initFields RIGHT_BRACE
         | UNDERSCORE
         | LEFT_PAREN qLexOp RIGHT_PAREN
         | LEFT_PAREN unOp RIGHT_PAREN

initFields ::= initField (COMMA initField)*

initField ::= VARID (EQUAL expr)

/* Sections */
section ::= LEFT_PAREN (binEx lexOp | lexOp expr) RIGHT_PAREN

/* Unit */
unit ::= LEFT_PAREN RIGHT_PAREN

/* Tuples */
tuple ::= tupleConstructor | nTuple | strictNTuple
tupleConstructor ::= LEFT_PAREN COMMA* RIGHT_PAREN
nTuple ::= LEFT_PAREN expr COMMA expr (COMMA expr)* RIGHT_PAREN
strictNTuple ::= LEFT_PAREN expr SEMICOLON expr (SEMICOLON expr)* RIGHT_PAREN

/* Lists */
list ::= emptyList
            | LEFT_BRACKET expr (COMMA expr)* RIGHT_BRACKET
            | LEFT_BRACKET (COMMA expr)? dotDot expr? RIGHT_BRACKET
            | LEFT_BRACKET expr VERT_BAR dlcqual (COMMA dlcqual)? RIGHT_BRACKET

dlcqual ::= pattern LEFT_ARROW expr
            | expr
            | LET VIRTUAL_OPEN_SECTION decl (VIRTUAL_END_DECL decl)* VIRTUAL_END_SECTION

emptyList ::= LEFT_BRACKET RIGHT_BRACKET

/* Primary Expression */
primaryInner ::= term
                    | QUALIFIER LEFT_BRACE VARID QUESTIONMARK RIGHT_BRACE
                    | QUALIFIER LEFT_BRACE VARID EQUAL RIGHT_BRACE
                    | QUALIFIER LEFT_BRACE VARID LEFT_ARROW RIGHT_BRACE
                    | QUALIFIER LEFT_BRACE field (COMMA field)* RIGHT_BRACE
                    | DO VIRTUAL_OPEN_SECTION dlcqual (VIRTUAL_END_DECL dlcqual)* VIRTUAL_END_SECTION

primary ::= primaryInner (DOT (
                VARID | lexOp | unOp |
                LEFT_BRACE VARID QUESTION_MARK RIGHT_BRACE |
                LEFT_BRACE VARID EQUAL RIGHT_BRACE |
                LEFT_BRACE VARID LEFT_ARROW RIGHT_BRACE |
                LEFT_BRACE field (COMMA field)* RIGHT_BRACE |
                LEFT_BRACKET expr RIGHT_BRACKET
                    ))* // was left rec

field ::= VARID EQUAL expr
            | VARID LEFT_ARROW expr
            | VARID

/* Lambda Expression */
lambda ::= BACK_SLASH pattern (lambda | RIGHT_ARROW expr)

/* Conditional */
cond ::= IF expr THEN expr ELSE expr

/* Let Expressions */
letEx ::= LET VIRTUAL_OPEN_SECTION decl (VIRTUAL_END_DECL decl)* VIRTUAL_END_SECTION IN expr

/* Case Expression */
casEx ::= CASE expr OF VIRTUAL_OPEN_SECTION alt (VIRTUAL_END_DECL alt)* VIRTUAL_END_SECTION
alt ::= pattern RIGHT_ARROW expr
        | pattern guardedExs
        | alt WHERE VIRTUAL_OPEN_SECTION decl (VIRTUAL_END_DECL decl)* VIRTUAL_END_SECTION
guardedExs ::= guardedEx+
guardedEx ::= VERT_BAR dlcqual (COMMA dlcqual)* EQUAL expr

/* Annotated Expression */
expr ::= topEx (DOUBLE_COLON sigma)?
topEx ::= casEx // TODO add do
            | letEx
            | cond
            | lambda
            | binEx

/* Binary application */
binEx ::= fExp (lexOp fExp)*

/* Function application */
fExp ::= primary+

/* Patterns */
pattern ::= atPattern (DOUBLE_COLON sigma)* // was left rec
    { pin=1 }

atPattern ::= pVar AT atPattern
                | listPattern
listPattern ::= matcherPattern (COLON listPattern)?
matcherPattern ::= pVar TILDA REGEX
                    | pconApp
pconApp ::= strictPattern+
strictPattern ::= EXLAMATION_MARK? pTerm
pTerm ::= CONID
            | CONID LEFT_BRACE patternFields? RIGHT_BRACE
            | pVar
            | literal
            | unit
            | emptyList
            | LEFT_BRACKET pattern (COMMA pattern)* RIGHT_BRACKET
            | LEFT_PAREN pattern (COMMA pattern)* RIGHT_PAREN
pVar ::= VARID
            | UNDERSCORE
patternFields ::= VARID EQUAL pattern (COMMA VARID EQUAL pattern)*

/* Declarations and Bindings */
program ::= (PACKAGE | MODULE) packageName inlineRule? WHERE VIRTUAL_OPEN_SECTION body VIRTUAL_END_SECTION?
    { pin=1 }

packageName ::= qConId
                | qVarId DOT packageName
                | qConId DOT packageName

inlineRule ::= INLINE LEFT_PAREN qName (COMMA qName)* RIGHT_PAREN // TODO qName??

body ::= topDecl (VIRTUAL_END_DECL topDecl)* // was right rec

topDecl ::= !<<eof>> (
              fixity
            | importDcl
            | accessModifier? typeDcl
            | accessModifier? dataDcl
            | accessModifier? classDcl
            | accessModifier? instDcl
            | accessModifier? deriveDcl
            | accessModifier? decl)
    { pin=1 recoverWhile=declRecover }

accessModifier ::= PUBLIC_MODIFIER | PROTECTED_MODIFIER | PRIVATE_MODIFIER

decl ::= annotation
            | binding
            | nativeFun

decls ::= decl (VIRTUAL_END_DECL decl)*

/* Syntax of Types */
sigma ::= (FORALL tyVar (tyVar)* DOT)? chro
chro ::= (constraints DOUBLE_RIGHT_ARROW)? rho
rho ::= LEFT_PAREN sigma RIGHT_PAREN RIGHT_ARROW rho
        | tyApp RIGHT_ARROW rho
        | tyApp
constraints ::= constraint
                | LEFT_PAREN constraints (COMMA constraint)* RIGHT_PAREN
constraint ::= className tyApp tyApp*
typeRule ::= tyApp (RIGHT_ARROW typeRule)* // was left rec
tyApp ::= simpleType+ // was left rec

simpleType ::= tyVar
                | tyCon
                | LEFT_PAREN typeRule RIGHT_BRACE
                | LEFT_PAREN typeRule COMMA typeRule (COMMA typeRule)* RIGHT_PAREN
                | LEFT_BRACKET typeRule RIGHT_BRACKET
                | LEFT_PAREN typeRule VERT_BAR typeRule (VERT_BAR typeRule)* RIGHT_PAREN
tyVar ::= VARID
            | LEFT_PAREN VARID DOUBLE_COLON kind RIGHT_PAREN
tvApp ::= tyVar
            | LEFT_PAREN tvApp tvApp* RIGHT_PAREN
tyCon ::= qConId
            | emptyList
            | unit
            | tupleConstructor
            | RIGHT_ARROW
className ::= qConId
kind ::= simpleKind
            | simpleKind RIGHT_ARROW kind
simpleKind ::= STAR
                | LEFT_PAREN kind RIGHT_PAREN



/* Algebraic Data type Declaration */
dataDcl ::= ABSTRACT? DATA CONID tyVar* EQUAL constructors (WHERE VIRTUAL_OPEN_SECTION decls VIRTUAL_END_SECTION)?
            | DATA CONID tyVar* EQUAL (MUTABLE|PURE)? NATIVE nativeName (WHERE VIRTUAL_OPEN_SECTION decls VIRTUAL_END_SECTION)? /* Native Datatype Declaration */
    { pin(".*")=DATA }

nativeName ::= (VARID | CONID) (DOT nativeName)?

constructors ::= constructor (VERT_BAR constructor)*

constructor ::= PRIVATE? CONID (LEFT_BRACE labels DOUBLE_COLON sigma (COMMA labels DOUBLE_COLON sigma)* RIGHT_BRACE | simpleType*)

labels ::= EXLAMATION_MARK? VARID (COMMA EXLAMATION_MARK? VARID)*

typeDcl ::= TYPE CONID (tyVar)* EQUAL sigma
    { pin=1 }

/* Class Declarations */
classDcl ::= (CLASS | INTERFACE) CONID (constraints DOUBLE_RIGHT_ARROW)? classVar (WHERE VIRTUAL_OPEN_SECTION decls VIRTUAL_END_SECTION)?
    { pin=1 }

classVar ::= VARID

/* Instance Declarations */
instDcl ::= INSTANCE className (constraints DOUBLE_RIGHT_ARROW)? typeRule (WHERE VIRTUAL_OPEN_SECTION decls VIRTUAL_END_SECTION)?
    { pin=1 }

/* Derived Instances */
deriveDcl ::= DERIVE className (constraints DOUBLE_RIGHT_ARROW)? typeRule
    { pin=1 }

/* fake function name rule for highlighting */
functionName ::= VARID {
    mixin="com.plugin.frege.psi.impl.FregeNamedElementImpl"
    implements="com.plugin.frege.psi.FregeNamedElement"
    methods=[getName setName getNameIdentifier]
}

/*  Type Annotations */
annotation ::= annoItem (COMMA annoItem)* DOUBLE_COLON sigma
    { pin=3 }
annoItem ::= functionName | symOp | UNOP

/*  Function and Pattern Bindings */
binding ::= lhs rhs
lhs ::= funLhs | pattern
funLhs ::= functionName pTerm*
            | pconApp lexOp pconApp
rhs ::= (EQUAL expr | guardedExs) (WHERE VIRTUAL_OPEN_SECTION decls VIRTUAL_END_SECTION)?
    { pin=1 }

/* Native Declaration */
nativeFun ::= PURE? NATIVE annoItem javaItem? DOUBLE_COLON sigma throwsRule?
    {pin=2}
javaItem ::= nativeName | unOp | symOp | STRING
throwsRule ::= THROWS typeRule (COMMA typeRule)*

/* Importing Packages */
importDcl ::= IMPORT packageName (AS? nameSpace)? PUBLIC_MODIFIER? importList?
    {pin=1}

importList ::= HIDING? LEFT_PAREN (importSpec (COMMA importSpec)*)? RIGHT_PAREN
importSpec ::= PUBLIC_MODIFIER? importItem alias?
importItem ::= VARID
                | CONID members?
                | symOp
                | CONID DOT (VARID | CONID | symOp)
alias ::= VARID | CONID | symOp
members ::= LEFT_PAREN (memSpec (COMMA memSpec)*)? RIGHT_PAREN
memSpec ::= PUBLIC_MODIFIER? member alias?
member ::= VARID | symOp | CONID
nameSpace ::= CONID



dotDot ::= DOT DOT // TODO move to lexer?


virtual ::= VIRTUAL_OPEN_SECTION | VIRTUAL_END_DECL | VIRTUAL_END_SECTION


todo ::= NEW_LINE | SYMBOL_OPERATOR | INTEGER | SLASH | STAR | TILDA | HASH | AT | COLON | DASH | FLOAT | REGEX | CHAR | WORD_OPERATOR | CASE | TRUE | PURE
            | CLASS | FALSE | INFIX | DERIVE | THROWS | NATIVE | INFIXL | INFIXR | IMPORT | MODULE | PUBLIC_MODIFIER | PLUS | LESS | GREATER
            | MUTABLE | INSTANCE | INTERFACE | PROTECTED_MODIFIER | OF | STRING | UNDERSCORE | QUESTION_MARK | DO | LEFT_ARROW | SLASH | LINE_COMMENT | BLOCK_COMMENT