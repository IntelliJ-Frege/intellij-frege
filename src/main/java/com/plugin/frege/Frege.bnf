{
    parserClass="com.plugin.frege.parser.FregeParser"
    parserUtilClass="com.plugin.frege.parser.FregeParserUtil"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Frege"
    psiImplClassSuffix="Impl"
    psiPackage="com.plugin.frege.psi"
    psiImplPackage="com.plugin.frege.psi.impl"

    elementTypeHolderClass="com.plugin.frege.psi.FregeTypes"
    elementTypeClass="com.plugin.frege.psi.FregeElementType"
    elementTypeFactory("nativeDataDecl|dataDecl|newtypeDecl|typeDecl|construct|program|binding|nativeFunction|classDecl|instanceDecl|annotationItem")
        ="com.plugin.frege.psi.FregeElementTypeFactory.factory"
    tokenTypeClass="com.plugin.frege.psi.FregeTokenType"
}

fregeFile ::= !<<eof>> program


/* Util Meta Rules */
private meta commaSequence ::= <<rule>> (COMMA <<rule>>)*
private meta semicolonSequence ::= <<rule>> (SEMICOLON <<rule>>)*

meta linearIndentSectionItemsVirtual ::= <<rule>> ((VIRTUAL_END_DECL | SEMICOLON VIRTUAL_END_DECL?) <<rule>>)*
meta linearIndentSectionItemsSemicolon ::= <<rule>> (SEMICOLON <<rule>>)*
meta linearIndentSection ::= VIRTUAL_OPEN_SECTION <<linearIndentSectionItemsVirtual <<rule>> >> SEMICOLON? VIRTUAL_END_SECTION
                        | LEFT_BRACE <<linearIndentSectionItemsSemicolon <<rule>> >> SEMICOLON? RIGHT_BRACE
                        | <<rule>> {
    implements="com.plugin.frege.psi.FregeScopeElement"
    mixin="com.plugin.frege.psi.mixin.indentsection.FregeLinearIndentSectionMixin"
}

meta nestedIndentSectionItemsVirtual ::= <<rule>> ((VIRTUAL_END_DECL | SEMICOLON VIRTUAL_END_DECL?) <<nestedIndentSectionItemsVirtual <<rule>> >>)? {
    implements="com.plugin.frege.psi.FregeScopeElement"
    mixin="com.plugin.frege.psi.mixin.indentsection.FregeNestedIndentSectionItemsMixin"
}
meta nestedIndentSectionItemsSemicolon ::= <<rule>> (SEMICOLON <<nestedIndentSectionItemsSemicolon <<rule>> >>)? {
    implements="com.plugin.frege.psi.FregeScopeElement"
    mixin="com.plugin.frege.psi.mixin.indentsection.FregeNestedIndentSectionItemsMixin"
}
meta nestedIndentSection ::= VIRTUAL_OPEN_SECTION <<nestedIndentSectionItemsVirtual <<rule>> >> SEMICOLON? VIRTUAL_END_SECTION
                        | LEFT_BRACE <<nestedIndentSectionItemsSemicolon <<rule>> >> SEMICOLON? RIGHT_BRACE
                        | <<rule>>


/* Varids and Conids */
private extendedVarid ::= VARID | weakKeyword
private weakKeyword ::= AS | HIDING | INLINE | MUTABLE | PURE
varidUsage ::= extendedVarid {
    implements="com.plugin.frege.psi.FregeCompositeElement"
    mixin="com.plugin.frege.psi.mixin.FregeVaridUsageMixin"
}
conidUsage ::= CONID {
    implements=["com.plugin.frege.psi.FregeCompositeElement"
                "com.intellij.psi.PsiIdentifier"]
    mixin="com.plugin.frege.psi.mixin.FregeConidUsageMixin"
}

qualifier ::= conidUsage DOT
qLexOperator ::= qualifier? qualifier? lexOperator
qVarid ::= qualifier qualifier varidUsage | qualifier varidUsage | varidUsage
qConid ::= qualifier qualifier conidUsage | qualifier conidUsage | conidUsage

// For real usages of these pseudo-keywords (for highlighting)
meta strongKeyword ::= <<keyword>>
private strongAs ::= <<strongKeyword AS>>
private strongHiding ::= <<strongKeyword HIDING>>
private strongInline ::= <<strongKeyword INLINE>>
private strongMutable ::= <<strongKeyword MUTABLE>>
private strongPure ::= <<strongKeyword PURE>>


/* Literals */
literal ::= boolLiteral
          | numericLiteral
          | CHAR
          | STRING
          | REGEX
numericLiteral ::= integralLiteral | floatLiteral
boolLiteral ::= TRUE | FALSE
integralLiteral ::= INTEGER
floatLiteral ::= FLOAT


/* Frege Program */
program ::= (PROTECTED_MODIFIER? (PACKAGE | MODULE) packageName inlineRule? WHERE VIRTUAL_OPEN_SECTION)? body {
    pin=1
    implements="com.plugin.frege.psi.FregePsiClass"
    mixin="com.plugin.frege.psi.mixin.FregeProgramMixin"
    stubClass="com.plugin.frege.stubs.FregeClassStub"
}
packageName ::= ((packageVarid | qConid) DOT)* qConid
private packageVarid ::= qualifier? qualifier? (extendedVarid | DATA | IMPORT | NATIVE | PACKAGE | MODULE | TYPE)
inlineRule ::= strongInline extendedVarid* LEFT_PAREN <<commaSequence (qVarid | qLexOperator)>> RIGHT_PAREN


/* Recovers */
private declRecover ::= !(VIRTUAL_END_DECL)


/* Importing Packages */
importDecl ::= IMPORT packageName (strongAs? conidUsage)? PUBLIC_MODIFIER? importList? {
    pin=1
}
importList ::= strongHiding? LEFT_PAREN (<<commaSequence importSpec>>)? RIGHT_PAREN
importSpec ::= PUBLIC_MODIFIER? importItem importAlias?
importItem ::= qVarid
             | conidUsage importMembers?
             | symbolOperatorQuoted
             | LEFT_PAREN symbolOperatorQuoted RIGHT_PAREN
             | BACK_QUOTE symbolOperatorQuoted BACK_QUOTE
             | conidUsage DOT (extendedVarid | conidUsage | symbolOperatorQuoted)
importAlias ::= extendedVarid | CONID | symbolOperatorQuoted
importMembers ::= LEFT_PAREN (<<commaSequence importMemberSpec>>)? RIGHT_PAREN
importMemberSpec ::= PUBLIC_MODIFIER? importMember importAlias?
importMember ::= extendedVarid | symbolOperatorQuoted | conidUsage


/* Main part of program */
body ::= topDecl (VIRTUAL_END_DECL topDecl)* {
    implements="com.plugin.frege.psi.FregeScopeElement"
    mixin="com.plugin.frege.psi.mixin.FregeBodyMixin"
}


/* Top-level declarations */
topDecl ::= !<<eof>> (
              fixity
            | importDecl
            | accessModifier? typeDecl
            | accessModifier? dataDecl
            | accessModifier? newtypeDecl
            | accessModifier? nativeDataDecl
            | accessModifier? classDecl
            | accessModifier? instanceDecl
            | accessModifier? deriveDecl
            | nativeModule
            | decl) SEMICOLON? {
    pin=1
    recoverWhile=declRecover
}


/* Access Modifiers */
accessModifier ::= PUBLIC_MODIFIER | PROTECTED_MODIFIER | PRIVATE_MODIFIER


/* Where Sections */
whereSection ::= WHERE <<linearIndentSection decl>> {
    pin=1
}


/* Functions */
decl ::= accessModifier? (annotation | binding | nativeFunction) {
    implements="com.plugin.frege.psi.FregeSubprogramsHolder"
}


/* Bindings */
binding ::= lhs rhs {
    implements=["com.plugin.frege.psi.FregePsiMethod"
                "com.plugin.frege.psi.FregeParametersHolder"
                "com.plugin.frege.psi.FregeWeakScopeElement"]
    mixin="com.plugin.frege.psi.mixin.FregeBindingMixin"
    stubClass="com.plugin.frege.stubs.FregeMethodStub"
}
lhs ::= functionLhs | pattern
functionLhs ::= strictPatterns lexOperator strictPatterns
              | (functionName | LEFT_PAREN symbolOperatorQuoted RIGHT_PAREN) strictPattern* // TODO unaryOperator?
rhs ::= (EQUAL expr | guardedExpressions) whereSection? {
    pin=1
}
functionName ::= extendedVarid {
    implements=["com.plugin.frege.psi.FregeCompositeElement"
                "com.intellij.psi.PsiIdentifier"]
    mixin="com.plugin.frege.psi.mixin.FregeFunctionNameMixin"
}


/*  Binding Annotations */
annotation ::= annotationItem (COMMA annotationItem)* DOUBLE_COLON sigma {
    pin=3
}
annotationItem ::= annotationName | LEFT_PAREN symbolOperatorQuoted RIGHT_PAREN | unaryOperator {
    implements="com.plugin.frege.psi.FregePsiMethod"
    mixin="com.plugin.frege.psi.mixin.FregeAnnotationItemMixin"
    stubClass="com.plugin.frege.stubs.FregeMethodStub"
}
annotationName ::= extendedVarid {
    implements=["com.plugin.frege.psi.FregeCompositeElement"
                "com.intellij.psi.PsiIdentifier"]
    mixin="com.plugin.frege.psi.mixin.FregeAnnotationNameMixin"
}


/* Native Bindings */
nativeFunction ::= strongPure? NATIVE nativeAnnotationItem javaItem? nativeTypeApplications? DOUBLE_COLON sigma (VERTICAL_BAR sigma)* throwsSequence? {
    pin=4
    implements="com.plugin.frege.psi.FregePsiMethod"
    mixin="com.plugin.frege.psi.mixin.FregeNativeFunctionMixin"
    stubClass="com.plugin.frege.stubs.FregeMethodStub"
}
nativeTypeApplications ::= LEFT_BRACE typeApplications? RIGHT_BRACE
javaItem ::= nativeName | unaryOperator | symbolOperatorQuoted | STRING
throwsSequence ::= THROWS <<commaSequence typeApplications>>
nativeAnnotationItem ::= nativeFunctionName | LEFT_PAREN (symbolOperatorQuoted | unaryOperator) RIGHT_PAREN | (symbolOperatorQuoted | unaryOperator)
nativeFunctionName ::= extendedVarid {
    implements=["com.plugin.frege.psi.FregeCompositeElement"
                "com.intellij.psi.PsiIdentifier"]
    mixin="com.plugin.frege.psi.mixin.FregeNativeFunctionNameMixin"
}


/* Fixity */
fixity ::= infixRule precedence (qLexOperator | extendedVarid)+ {
    pin=1
}
precedence ::= INTEGER
infixRule ::= INFIX | INFIXL | INFIXR


/* Type Declarations */
typeDecl ::= TYPE conidUsage (typedVarid)* EQUAL sigma {
    pin=1
    implements="com.plugin.frege.psi.FregePsiClass"
    mixin="com.plugin.frege.psi.mixin.FregeTypeDeclMixin"
    stubClass="com.plugin.frege.stubs.FregeClassStub"
}


/* Class Declarations */
classDecl ::= (CLASS | INTERFACE) constraints ( DOUBLE_RIGHT_ARROW conidUsage typedVarid)?  whereSection? {
    pin=1
    implements="com.plugin.frege.psi.FregePsiClass"
    mixin="com.plugin.frege.psi.mixin.FregeClassDeclMixin"
    stubClass="com.plugin.frege.stubs.FregeClassStub"
}


/* Instance Declarations */
instanceDecl ::= INSTANCE (constraints DOUBLE_RIGHT_ARROW)? conidUsage typeApplications whereSection? {
    pin=1
    implements="com.plugin.frege.psi.FregePsiClass"
    mixin="com.plugin.frege.psi.mixin.FregeInstanceDeclMixin"
    stubClass="com.plugin.frege.stubs.FregeClassStub"
}


/* Derived Instances */
deriveDecl ::= DERIVE conidUsage (constraints DOUBLE_RIGHT_ARROW)? typeApplications {
    pin=1
}


/* Data Declarations */
dataDecl ::= ABSTRACT? DATA conidUsage typedVarid* EQUAL constructs whereSection? deriveDecl? {
    pin=6
    implements="com.plugin.frege.psi.FregePsiClass"
    mixin="com.plugin.frege.psi.mixin.FregeDataDeclMixin"
    stubClass="com.plugin.frege.stubs.FregeClassStub"
}
constructs ::= construct (VERTICAL_BAR construct)*
construct ::= accessModifier? (EXLAMATION_MARK? conidUsage) (
          LEFT_BRACE <<commaSequence (labels DOUBLE_COLON sigma)>> RIGHT_BRACE | simpleType*) {
    implements="com.plugin.frege.psi.FregePsiMethod"
    mixin="com.plugin.frege.psi.mixin.FregeConstructMixin"
    stubClass="com.plugin.frege.stubs.FregeMethodStub"
}
labels ::= <<commaSequence label>>
label ::= EXLAMATION_MARK? extendedVarid

/* Newtype Declarations */
newtypeDecl ::= ABSTRACT? NEWTYPE conidUsage typedVarid* EQUAL construct whereSection? {
    pin=2
    implements="com.plugin.frege.psi.FregePsiClass"
    mixin="com.plugin.frege.psi.mixin.FregeNewtypeDeclMixin"
    stubClass="com.plugin.frege.stubs.FregeClassStub"
}


/* Native Data Declarations */
nativeDataDecl ::= DATA conidUsage typedVarid* EQUAL (strongMutable|strongPure)? NATIVE nativeName nativeTypeApplications? whereSection? deriveDecl? {
    pin=6
    implements="com.plugin.frege.psi.FregePsiClass"
    mixin="com.plugin.frege.psi.mixin.FregeNativeDataDeclMixin"
    stubClass="com.plugin.frege.stubs.FregeClassStub"
}
nativeName ::= (extendedVarid | CONID) (DOT (extendedVarid | CONID))* {
    implements="com.plugin.frege.psi.FregeCompositeElement"
    mixin="com.plugin.frege.psi.mixin.FregeNativeNameMixin"
}

/* Native module */
nativeModule ::= NATIVE MODULE (TYPE typeApplications)? (CLASS <<commaSequence constraint>>)? WHERE LEFT_BRACE javaCode RIGHT_BRACE {
    pin=2
}
external javaCode ::= javaCodeParseExternal


/* Expression */
expr ::= binaryExpression (DOUBLE_COLON (FORALL | rho))?
binaryExpression ::= topExpression (qLexOperator topExpression)*
topExpression ::= condition
                | letInExpression
                | caseExpression
                | lambda
                | ((EXLAMATION_MARK | QUESTION_MARK)* primary)+

/* Lambda Expressions */
lambda ::= BACK_SLASH pattern (lambda | RIGHT_ARROW expr)

/* Do Expressions */
doExpression ::= DO <<nestedIndentSection (doDecl | qConid LEFT_BRACE fieldsOrVaridInit RIGHT_BRACE)>>
doDecl ::= letExpression | pattern (LEFT_ARROW | EQUAL) expr | expr {
    implements=["com.plugin.frege.psi.FregeSubprogramsHolder"
                "com.plugin.frege.psi.FregeScopeElement"]
    mixin="com.plugin.frege.psi.mixin.indentsection.FregeDoDeclMixin"
}

/* Case Expressions */
caseExpression ::= CASE expr OF <<linearIndentSection caseDecl>> {
    pin=1
}
caseDecl ::= pattern ((RIGHT_ARROW | EQUAL) expr | guardedExpressions) whereSection? {
    pin=2
    implements=["com.plugin.frege.psi.FregeParametersHolder"
                "com.plugin.frege.psi.FregeWeakScopeElement"]
    mixin="com.plugin.frege.psi.mixin.indentsection.FregeCaseDeclMixin"
}

/* If Condition Expressions */
condition ::= IF expr (VIRTUAL_END_DECL | SEMICOLON)? THEN expr (VIRTUAL_END_DECL | SEMICOLON)? ELSE expr {
    pin=1
}

/* Let Expressions */
letExpression ::= LET <<linearIndentSection decl>> {
    pin=1
}
letInExpression ::= letExpression IN expr {
    pin=1
    implements="com.plugin.frege.psi.FregeScopeElement"
    mixin="com.plugin.frege.psi.mixin.indentsection.FregeLetInExpressionMixin"
}

/* Guarded Expressions */
guardedExpressions ::= guardedExpression+
guardedExpression ::= VERTICAL_BAR guardDecls (RIGHT_ARROW | EQUAL) expr
guardDecls ::= <<commaSequence guardDecl>> COMMA?
guardDecl ::= expr (LEFT_ARROW expr)?


/* Primary Expression */
primary ::= (term | doExpression) (DOT (
                extendedVarid
              | qLexOperator
              | EXLAMATION_MARK
              | QUESTION_MARK
              | LEFT_BRACE fieldsOrVaridInit RIGHT_BRACE
              | LEFT_BRACKET expr RIGHT_BRACKET))*
fieldsOrVaridInit ::= extendedVarid (QUESTION_MARK | EQUAL | LEFT_ARROW)? (
    expr (COMMA getField)* COMMA?)?
getField ::= extendedVarid ((LEFT_ARROW | EQUAL) expr)?

/* Terms */
term ::= qVarid
       | qConid LEFT_BRACE initFields? RIGHT_BRACE
       | qConid
       | literal
       | LEFT_PAREN qLexOperator RIGHT_PAREN
       | LEFT_PAREN unaryOperator RIGHT_PAREN
       | LEFT_PAREN expr RIGHT_PAREN
       | list
       | slice
       | unit
       | tuple
       | UNDERSCORE
initFields ::= <<commaSequence initField>>
initField ::= extendedVarid (EQUAL expr)?
slice ::= LEFT_PAREN (binaryExpression qLexOperator | qLexOperator expr) RIGHT_PAREN
unit ::= LEFT_PAREN RIGHT_PAREN
tuple ::= tupleConstructor | nTuple | strictNTuple
tupleConstructor ::= LEFT_PAREN COMMA* RIGHT_PAREN
nTuple ::= LEFT_PAREN expr COMMA <<commaSequence expr>> RIGHT_PAREN
strictNTuple ::= LEFT_PAREN expr SEMICOLON <<semicolonSequence expr>> RIGHT_PAREN

/* Lists */
list ::= emptyList
       | LEFT_BRACKET <<commaSequence expr>> COMMA? RIGHT_BRACKET
       | LEFT_BRACKET expr (COMMA expr)? DOUBLE_DOT expr? RIGHT_BRACKET
       | LEFT_BRACKET expr VERTICAL_BAR <<commaSequence doDecl>> COMMA? RIGHT_BRACKET
emptyList ::= LEFT_BRACKET RIGHT_BRACKET

/* Patterns */
pattern ::= atPattern (DOUBLE_COLON sigma)* {
    pin=1
}
atPattern ::= parameterPattern AT atPattern
            | matcherPattern (COLON matcherPattern)*
matcherPattern ::= parameterPattern TILDA REGEX | strictPatterns
strictPatterns ::= strictPattern+
strictPattern ::= EXLAMATION_MARK? patternTerm
patternTerm ::= qConid LEFT_BRACE patternFields? RIGHT_BRACE
              | qConid
              | parameterPattern
              | literal
              | unit
              | emptyList
              | LEFT_BRACKET pattern (COMMA pattern)* RIGHT_BRACKET
              | LEFT_PAREN parameterPattern SUPER_OR_SUBSCRIPT RIGHT_PAREN
              | LEFT_PAREN pattern (COMMA pattern)* RIGHT_PAREN
parameterPattern ::= parameter | UNDERSCORE
patternFields ::= <<commaSequence patternField>>
patternField ::= parameter (EQUAL pattern)?
parameter ::= extendedVarid {
    mixin="com.plugin.frege.psi.mixin.FregeParamMixin"
    implements="com.plugin.frege.psi.FregeNamedElement"
}


/* Types */
sigma ::= (FORALL typedVarid (typedVarid)* DOT)? (constraints DOUBLE_RIGHT_ARROW)? rho
rho ::= LEFT_PAREN sigma RIGHT_PAREN RIGHT_ARROW rho
      | typeApplication RIGHT_ARROW rho
      | typeApplication
constraints ::= constraint | LEFT_PAREN <<commaSequence constraint>> COMMA? RIGHT_PAREN
constraint ::= conidUsage typeApplication+
typeApplications ::= typeApplication (RIGHT_ARROW typeApplication)*
typeApplication ::= simpleType+

simpleType ::= typedVarid
             | typedConid
             | LEFT_PAREN typeApplications RIGHT_PAREN
             | LEFT_PAREN typeApplications COMMA typeApplications (COMMA typeApplications)* RIGHT_PAREN
             | LEFT_BRACKET typeApplications RIGHT_BRACKET
             | LEFT_PAREN typeApplications VERTICAL_BAR typeApplications (VERTICAL_BAR typeApplications)* RIGHT_PAREN
typedVarid ::= extendedVarid | LEFT_PAREN extendedVarid DOUBLE_COLON kind RIGHT_PAREN
typedConid ::= qConid
             | emptyList
             | unit
             | tupleConstructor
             | RIGHT_ARROW
kind ::= simpleKind (RIGHT_ARROW kind)?
simpleKind ::= STAR | LEFT_PAREN kind RIGHT_PAREN


/* Operators */
private preservedAloneOperators ::= STAR | COLON | SUPER_OR_SUBSCRIPT
                                  | DOT | AT | TILDA | EXLAMATION_MARK | QUESTION_MARK // TODO AT is not an operator
symbolOperator ::= SYM_OPERATOR_NO_FIRST_DOT | DOT+ SYM_OPERATOR_NO_FIRST_DOT | preservedAloneOperators {
    implements=["com.plugin.frege.psi.FregeCompositeElement"
                "com.intellij.psi.PsiIdentifier"]
    mixin="com.plugin.frege.psi.mixin.FregeSymbolOperatorMixin"
}
symbolOperatorQuoted ::= symbolOperator | BACK_QUOTE symbolOperator BACK_QUOTE
lexOperator ::= WORD_OPERATOR | symbolOperatorQuoted
unaryOperator ::= EXLAMATION_MARK | QUESTION_MARK


todo ::= NEW_LINE | LESS | GREATER | LINE_COMMENT | BLOCK_COMMENT | DEFAULT | FOREIGN | NEWTYPE | DERIVING
