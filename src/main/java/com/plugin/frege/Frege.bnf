{
    parserClass="com.plugin.frege.parser.FregeParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Frege"
    psiImplClassSuffix="Impl"
    psiPackage="com.plugin.frege.psi"
    psiImplPackage="com.plugin.frege.psi.impl"

    elementTypeHolderClass="com.plugin.frege.psi.FregeTypes"
    elementTypeClass="com.plugin.frege.psi.FregeElementType"
    tokenTypeClass="com.plugin.frege.psi.FregeTokenType"
}

fregeFile ::= !<<eof>> program

private declRecover ::= !(VIRTUAL_END_DECL)

/* Operators */
precedence ::= INTEGER
fixity ::= infixRule precedence lexOp+
    { pin=1 }

infixRule ::= INFIX | INFIXL | INFIXR
private opCharsCanUseAlone ::= (EXLAMATION_MARK | QUESTION_MARK | HASH | TILDA | PLUS |
            DOT | STAR | AT | DASH | SLASH | BACK_SLASH | DOLLAR |
            RIGHT_ARROW | LEFT_ARROW | DOUBLE_RIGHT_ARROW | LESS | GREATER | COLON | AMPERSAND | DEGREE_SIGN) // TODO %^
private cannotAlone ::= EQUAL | VERT_BAR | DOUBLE_COLON
symOp ::= opCharsCanUseAlone (opCharsCanUseAlone | cannotAlone)*
            | cannotAlone (opCharsCanUseAlone | cannotAlone)+

lexOp ::= WORD_OPERATOR | symOp

/* Unary operators */
unOp ::= EXLAMATION_MARK | QUESTION_MARK

/* Imported operators */
// Unary operators can not be qualified.
weakVarid ::= VARID | weakIdentifier
weakIdentifier ::= AS | DATA | DERIVE | HIDING | INFIX | INFIXL | INFIXR | INSTANCE | MUTABLE |
                   NATIVE | OF | PURE | TYPE // TODO list of weak identifiers is probably wrong; fix coloring
qualifier ::= CONID DOT
qLexOp ::= qualifier? qualifier? lexOp
qVarId ::= qualifier? qualifier? weakVarid {
    implements="com.plugin.frege.psi.FregeCompositeElement"
    mixin="com.plugin.frege.psi.mixin.FregeQVaridMixin"
}
qConId ::= qualifier? qualifier? dataNameUsage

/* Literals */
literal ::= boolLiteral
            | numericLiteral
            | CHAR
            | STRING
            | REGEX
numericLiteral ::= integralLiteral
                    | floatLiteral
boolLiteral ::= TRUE | FALSE
integralLiteral ::= INTEGER
floatLiteral ::= FLOAT

/* Terms */
term ::= qVarId
         | qConId
         | literal
         | LEFT_PAREN expr RIGHT_PAREN
         | list
         | section
         | unit
         | tuple
         | qConId LEFT_BRACE initFields RIGHT_BRACE
         | UNDERSCORE
         | LEFT_PAREN qLexOp RIGHT_PAREN
         | LEFT_PAREN unOp RIGHT_PAREN

initFields ::= initField (COMMA initField)*

initField ::= weakVarid (EQUAL expr)

/* Sections */
section ::= LEFT_PAREN (binEx lexOp | lexOp expr) RIGHT_PAREN

/* Unit */
unit ::= LEFT_PAREN RIGHT_PAREN

/* Tuples */
tuple ::= tupleConstructor | nTuple | strictNTuple
tupleConstructor ::= LEFT_PAREN COMMA* RIGHT_PAREN
nTuple ::= LEFT_PAREN expr COMMA expr (COMMA expr)* RIGHT_PAREN
strictNTuple ::= LEFT_PAREN expr SEMICOLON expr (SEMICOLON expr)* RIGHT_PAREN

/* Lists */
list ::= emptyList
            | LEFT_BRACKET expr (COMMA expr)* RIGHT_BRACKET
            | LEFT_BRACKET expr (COMMA expr)? DOUBLE_DOT expr? RIGHT_BRACKET
            | LEFT_BRACKET expr VERT_BAR dlcqual (COMMA dlcqual)? RIGHT_BRACKET

dlcqual ::= pattern LEFT_ARROW expr
            | expr
            | letExpression

emptyList ::= LEFT_BRACKET RIGHT_BRACKET

/* Primary Expression */
primaryInner ::= term
                    | qualifier LEFT_BRACE weakVarid QUESTIONMARK RIGHT_BRACE
                    | qualifier LEFT_BRACE weakVarid EQUAL RIGHT_BRACE
                    | qualifier LEFT_BRACE weakVarid LEFT_ARROW RIGHT_BRACE
                    | qualifier LEFT_BRACE field (COMMA field)* RIGHT_BRACE
                    | doEx

primary ::= primaryInner (DOT (
                weakVarid | lexOp | unOp |
                LEFT_BRACE weakVarid QUESTION_MARK RIGHT_BRACE |
                LEFT_BRACE weakVarid EQUAL RIGHT_BRACE |
                LEFT_BRACE weakVarid LEFT_ARROW RIGHT_BRACE |
                LEFT_BRACE field (COMMA field)* RIGHT_BRACE |
                LEFT_BRACKET expr RIGHT_BRACKET
                    ))* // was left rec

field ::= weakVarid EQUAL expr
            | weakVarid LEFT_ARROW expr
            | weakVarid

/* Lambda Expression */
lambda ::= BACK_SLASH pattern (lambda | RIGHT_ARROW expr)

/* Conditional */
cond ::= IF expr THEN expr ELSE expr

/* Let, Where and Do Expressions */
meta indentSection ::= VIRTUAL_OPEN_SECTION <<rule>> ((VIRTUAL_END_DECL | SEMICOLON) <<rule>>)* VIRTUAL_END_SECTION
                        | LEFT_BRACE <<rule>> (SEMICOLON <<rule>>)* RIGHT_BRACE
letExpression ::= LET <<indentSection decl>>
letInExpression ::= letExpression IN expr
whereSection ::= WHERE <<indentSection decl>>
doEx ::= DO <<indentSection dlcqual>>

/* Case Expression */
caseEx ::= CASE expr OF <<indentSection alt>>
alt ::= pattern RIGHT_ARROW expr
        | pattern guardedExs
        | alt whereSection
guardedExs ::= guardedEx+
guardedEx ::= VERT_BAR dlcqual (COMMA dlcqual)* EQUAL expr

/* Annotated Expression */
expr ::= topEx (DOUBLE_COLON sigma)?
topEx ::= caseEx // TODO add do
            | letInExpression
            | cond
            | lambda
            | binEx

/* Binary application */
binEx ::= fExp (lexOp fExp)*

/* Function application */
fExp ::= primary+

/* Patterns */
param ::= weakVarid {
    mixin="com.plugin.frege.psi.mixin.FregeParamMixin"
    implements="com.plugin.frege.psi.FregeNamedElement"
}

pattern ::= atPattern (DOUBLE_COLON sigma)* // was left rec
    { pin=1 }

atPattern ::= pVar AT atPattern
                | listPattern
listPattern ::= matcherPattern (COLON listPattern)?
matcherPattern ::= pVar TILDA REGEX
                    | pconApp
pconApp ::= strictPattern+
strictPattern ::= EXLAMATION_MARK? pTerm
pTerm ::= dataNameUsage
            | dataNameUsage LEFT_BRACE patternFields? RIGHT_BRACE
            | pVar
            | literal
            | unit
            | emptyList
            | LEFT_BRACKET pattern (COMMA pattern)* RIGHT_BRACKET
            | LEFT_PAREN pattern (COMMA pattern)* RIGHT_PAREN
pVar ::= param
            | UNDERSCORE
patternFields ::= param EQUAL pattern (COMMA param EQUAL pattern)*

/* Declarations and Bindings */
program ::= (PACKAGE | MODULE) packageName inlineRule? WHERE VIRTUAL_OPEN_SECTION body
    { pin=1 }

packageName ::= qConId
                | qVarId DOT packageName
                | qConId DOT packageName

qName ::= qVarId
inlineRule ::= INLINE LEFT_PAREN qName (COMMA qName)* RIGHT_PAREN

body ::= topDecl (VIRTUAL_END_DECL topDecl)* // was right rec

topDecl ::= !<<eof>> (
              fixity
            | importDcl
            | accessModifier? typeDcl
            | accessModifier? dataDcl
            | accessModifier? classDcl
            | accessModifier? instDcl
            | accessModifier? deriveDcl
            | accessModifier? decl)
    { pin=1 recoverWhile=declRecover }

accessModifier ::= PUBLIC_MODIFIER | PROTECTED_MODIFIER | PRIVATE_MODIFIER

decl ::= annotation
            | binding
            | nativeFun

/* Syntax of Types */
sigma ::= (FORALL tyVar (tyVar)* DOT)? chro
chro ::= (constraints DOUBLE_RIGHT_ARROW)? rho
rho ::= LEFT_PAREN sigma RIGHT_PAREN RIGHT_ARROW rho
        | tyApp RIGHT_ARROW rho
        | tyApp
constraints ::= constraint
                | LEFT_PAREN constraints (COMMA constraint)* RIGHT_PAREN
constraint ::= className tyApp tyApp*
typeRule ::= tyApp (RIGHT_ARROW typeRule)* // was left rec
tyApp ::= simpleType+ // was left rec

simpleType ::= tyVar
                | tyCon
                | LEFT_PAREN typeRule RIGHT_PAREN
                | LEFT_PAREN typeRule COMMA typeRule (COMMA typeRule)* RIGHT_PAREN
                | LEFT_BRACKET typeRule RIGHT_BRACKET
                | LEFT_PAREN typeRule VERT_BAR typeRule (VERT_BAR typeRule)* RIGHT_PAREN
tyVar ::= weakVarid
            | LEFT_PAREN weakVarid DOUBLE_COLON kind RIGHT_PAREN
tvApp ::= tyVar
            | LEFT_PAREN tvApp tvApp* RIGHT_PAREN
tyCon ::= qConId
            | emptyList
            | unit
            | tupleConstructor
            | RIGHT_ARROW
className ::= qConId
kind ::= simpleKind
            | simpleKind RIGHT_ARROW kind
simpleKind ::= STAR
                | LEFT_PAREN kind RIGHT_PAREN



/* Algebraic Data type Declaration */
dataDcl ::= (dataDclConstructors | dataDclNative) deriveDcl?
    { pin=1 }

dataDclConstructors ::= ABSTRACT? DATA dataName tyVar* EQUAL constructors whereSection?
    { pin=6 }
dataDclNative ::= DATA dataName tyVar* EQUAL (MUTABLE|PURE)? NATIVE nativeName whereSection?
    { pin=6 }

dataName ::= CONID {
    implements="com.plugin.frege.psi.FregeNamedElement"
    mixin="com.plugin.frege.psi.mixin.FregeDataNameMixin"
}
dataNameUsage ::= CONID {
    implements="com.plugin.frege.psi.FregeCompositeElement"
    mixin="com.plugin.frege.psi.mixin.FregeDataNameUsageMixin"
}

nativeName ::= (weakVarid | CONID) (DOT (weakVarid | CONID))* {
    implements="com.plugin.frege.psi.FregeCompositeElement"
    mixin="com.plugin.frege.psi.mixin.FregeNativeNameMixin"
}

constructors ::= constructor (VERT_BAR constructor)*

constructor ::= PRIVATE? (EXLAMATION_MARK? dataNameUsage) (LEFT_BRACE labels DOUBLE_COLON sigma (COMMA labels DOUBLE_COLON sigma)* RIGHT_BRACE | (simpleType | bracedConstructor)*)
bracedConstructor ::= LEFT_PAREN (bracedConstructor | constructor) RIGHT_PAREN

labels ::= label (COMMA label)*
label ::= EXLAMATION_MARK? weakVarid

typeDcl ::= TYPE dataName (tyVar)* EQUAL sigma
    { pin=1 }

/* Class Declarations */
classDcl ::= (CLASS | INTERFACE) CONID (constraints DOUBLE_RIGHT_ARROW)? classVar whereSection?
    { pin=1 }

classVar ::= weakVarid

/* Instance Declarations */
instDcl ::= INSTANCE (constraints DOUBLE_RIGHT_ARROW)? className typeRule whereSection?
    { pin=1 }

/* Derived Instances */
deriveDcl ::= DERIVE className (constraints DOUBLE_RIGHT_ARROW)? typeRule
    { pin=1 }

/* fake function name rule for highlighting */
functionName ::= weakVarid {
    mixin="com.plugin.frege.psi.mixin.FregeFunctionNameMixin"
    implements="com.plugin.frege.psi.FregeNamedElement"
}

/*  Type Annotations */
annotation ::= annoItem (COMMA annoItem)* DOUBLE_COLON sigma
    { pin=3 }
annoItem ::= functionName | LEFT_PAREN symOp RIGHT_PAREN | UNOP

/*  Function and Pattern Bindings */
binding ::= lhs rhs
lhs ::= funLhs | pattern
funLhs ::= pconApp lexOp pconApp
            | (functionName | LEFT_PAREN symOp RIGHT_PAREN) strictPattern* // TODO UNOP?
rhs ::= (EQUAL expr | guardedExs) whereSection?
    { pin=1 }

/* Native Declaration */
nativeFun ::= PURE? NATIVE annoItem javaItem? DOUBLE_COLON sigma (VERT_BAR sigma)* throwsRule?
    { pin=2 }
javaItem ::= nativeName | unOp | symOp | STRING
throwsRule ::= THROWS typeRule (COMMA typeRule)*

/* Importing Packages */
importDcl ::= IMPORT packageName (AS? nameSpace)? PUBLIC_MODIFIER? importList?
    { pin=1 }

importList ::= HIDING? LEFT_PAREN (importSpec (COMMA importSpec)*)? RIGHT_PAREN
importSpec ::= PUBLIC_MODIFIER? importItem alias?
importItem ::= weakVarid
                | CONID members?
                | symOp
                | LEFT_PAREN symOp RIGHT_PAREN
                | BACK_QUOTE symOp BACK_QUOTE
                | CONID DOT (weakVarid | CONID | symOp)
alias ::= weakVarid | CONID | symOp
members ::= LEFT_PAREN (memSpec (COMMA memSpec)*)? RIGHT_PAREN
memSpec ::= PUBLIC_MODIFIER? member alias?
member ::= weakVarid | symOp | CONID
nameSpace ::= CONID


todo ::= NEW_LINE | SYMBOL_OPERATOR | INTEGER | SLASH | STAR | TILDA | HASH | AT | COLON | DASH | FLOAT | REGEX | CHAR | WORD_OPERATOR | CASE | TRUE | PURE
            | CLASS | FALSE | INFIX | DERIVE | THROWS | NATIVE | INFIXL | INFIXR | IMPORT | MODULE | PUBLIC_MODIFIER | PLUS | LESS | GREATER
            | MUTABLE | INSTANCE | INTERFACE | PROTECTED_MODIFIER | OF | STRING | UNDERSCORE | QUESTION_MARK | DO | LEFT_ARROW | SLASH | LINE_COMMENT | BLOCK_COMMENT