{
    parserClass="com.plugin.frege.parser.FregeParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Frege"
    psiImplClassSuffix="Impl"
    psiPackage="com.plugin.frege.psi"
    psiImplPackage="com.plugin.frege.psi.impl"

    elementTypeHolderClass="com.plugin.frege.psi.FregeTypes"
    elementTypeClass="com.plugin.frege.psi.FregeElementType"
    tokenTypeClass="com.plugin.frege.psi.FregeTokenType"
}

fregeFile ::= !<<eof>> program

private declRecover ::= !(VIRTUAL_END_DECL)

/* Operators */
precedence ::= INTEGER
fixity ::= infixRule precedence (lexOp | BACK_QUOTE lexOp BACK_QUOTE)+
    { pin=1 }

infixRule ::= INFIX | INFIXL | INFIXR
private opCharsCanUseAlone ::= (EXLAMATION_MARK | QUESTION_MARK | HASH | TILDA | PLUS |
            DOT | STAR | AT | DASH | SLASH | BACK_SLASH | DOLLAR |
            RIGHT_ARROW | LEFT_ARROW | DOUBLE_RIGHT_ARROW | LESS | GREATER | COLON |
            AMPERSAND | DEGREE_SIGN | CARRET | PERCENT | UNKNOWN_SYMBOL)
private cannotAlone ::= EQUAL | VERT_BAR | DOUBLE_COLON
symOp ::= opCharsCanUseAlone (opCharsCanUseAlone | cannotAlone)*
            | cannotAlone (opCharsCanUseAlone | cannotAlone)+

lexOp ::= WORD_OPERATOR | symOp

/* Unary operators */
unOp ::= EXLAMATION_MARK | QUESTION_MARK

/* Imported operators */
// Unary operators can not be qualified.
private weakVarid ::= VARID | weakKeyword
private weakKeyword ::= AS | HIDING | INLINE | MUTABLE | PURE

/* for real usages of these pseudo-keywords (for highlighting) */
meta strongKeyword ::= <<keyword>>
private strongAs ::= <<strongKeyword AS>>
private strongHiding ::= <<strongKeyword HIDING>>
private strongInline ::= <<strongKeyword INLINE>>
private strongMutable ::= <<strongKeyword MUTABLE>>
private strongPure ::= <<strongKeyword PURE>>

qualifier ::= CONID DOT
qLexOp ::= qualifier? qualifier? lexOp
qVarId ::= qualifier? qualifier? weakVarid {
    implements="com.plugin.frege.psi.FregeCompositeElement"
    mixin="com.plugin.frege.psi.mixin.FregeQVaridMixin"
}
qConId ::= qualifier? qualifier? dataNameUsage

/* Literals */
literal ::= boolLiteral
            | numericLiteral
            | CHAR
            | STRING
            | REGEX
numericLiteral ::= integralLiteral
                    | floatLiteral
boolLiteral ::= TRUE | FALSE
integralLiteral ::= INTEGER
floatLiteral ::= FLOAT

/* Terms */
term ::= qVarId
         | qConId LEFT_BRACE initFields? RIGHT_BRACE
         | qConId
         | literal
         | LEFT_PAREN expr RIGHT_PAREN
         | list
         | section
         | unit
         | tuple
         | UNDERSCORE
         | LEFT_PAREN qLexOp RIGHT_PAREN
         | LEFT_PAREN unOp RIGHT_PAREN

initFields ::= initField (COMMA initField)*

initField ::= weakVarid (EQUAL expr)

/* Sections */
section ::= LEFT_PAREN (binEx lexOp | lexOp expr) RIGHT_PAREN

/* Unit */
unit ::= LEFT_PAREN RIGHT_PAREN

/* Tuples */
tuple ::= tupleConstructor | nTuple | strictNTuple
tupleConstructor ::= LEFT_PAREN COMMA* RIGHT_PAREN
nTuple ::= LEFT_PAREN expr COMMA expr (COMMA expr)* RIGHT_PAREN
strictNTuple ::= LEFT_PAREN expr SEMICOLON expr (SEMICOLON expr)* RIGHT_PAREN

/* Lists */
list ::= emptyList
            | LEFT_BRACKET expr (COMMA expr)* COMMA? RIGHT_BRACKET
            | LEFT_BRACKET expr (COMMA expr)? DOUBLE_DOT expr? RIGHT_BRACKET
            | LEFT_BRACKET expr VERT_BAR lcquals RIGHT_BRACKET
lcquals ::= lcqual (COMMA lcqual)* COMMA?
lcqual ::= letExpression | expr ((LEFT_ARROW | EQUAL) expr)? {
    implements="com.plugin.frege.psi.FregeSubprogramsHolder"
}

emptyList ::= LEFT_BRACKET RIGHT_BRACKET

/* Primary Expression */
primary ::= (term | doEx) (DOT (
                VARID
              | qLexOp
              | EXLAMATION_MARK
              | QUESTION_MARK
              | LEFT_BRACE (getFields | weakVarid (QUESTION_MARK | EQUAL | LEFT_ARROW)) RIGHT_BRACE
              | LEFT_BRACKET expr RIGHT_BRACKET))*

getFields ::= getField (COMMA getFields)* COMMA?
getField ::= weakVarid ((LEFT_ARROW | EQUAL) expr)?

/* Lambda Expression */
lambda ::= BACK_SLASH pattern (lambda | RIGHT_ARROW expr)

/* Conditional */
cond ::= IF expr (VIRTUAL_END_DECL | SEMICOLON)? THEN expr (VIRTUAL_END_DECL | SEMICOLON)? ELSE expr

/* Let, Where and Do Expressions */
meta indentSection ::= VIRTUAL_OPEN_SECTION <<rule>> ((VIRTUAL_END_DECL | SEMICOLON) <<rule>>)* VIRTUAL_END_SECTION
                        | LEFT_BRACE <<rule>> (SEMICOLON <<rule>>)* RIGHT_BRACE
                        | <<rule>>
letExpression ::= LET <<indentSection decl>>
letInExpression ::= letExpression IN expr {
    implements="com.plugin.frege.psi.FregeScopeElement"
    mixin="com.plugin.frege.psi.mixin.FregeLetInExpressionMixin"
}
whereSection ::= WHERE <<indentSection decl>> {
    implements="com.plugin.frege.psi.FregeScopeElement"
    mixin="com.plugin.frege.psi.mixin.FregeWhereSectionMixin"
}
doEx ::= DO <<indentSection (lcqual | qConId LEFT_BRACE (getFields | weakVarid (QUESTION_MARK | EQUAL | LEFT_ARROW)) RIGHT_BRACE)>>

/* Case Expression */
caseEx ::= CASE expr OF <<indentSection alt>>
alt ::= pattern ((RIGHT_ARROW | EQUAL) expr | guardedExs) whereSection? {
    implements="com.plugin.frege.psi.FregeSubprogramsHolder"
}
guardedExs ::= guardedEx+
guardedEx ::= VERT_BAR gquals (RIGHT_ARROW | EQUAL) expr
gquals ::= gqual (COMMA gqual)* COMMA?
gqual ::= expr (LEFT_ARROW expr)?

/* Annotated Expression */
expr ::= binEx (DOUBLE_COLON (FORALL | rho))?
topEx ::= cond
        | letInExpression
        | caseEx
        | lambda
        | ((EXLAMATION_MARK | QUESTION_MARK)* primary)+
/* Binary application */
binEx ::= topEx (qLexOp topEx)*

/* Patterns */
param ::= weakVarid {
    mixin="com.plugin.frege.psi.mixin.FregeParamMixin"
    implements="com.plugin.frege.psi.FregeNamedElement"
}

pattern ::= atPattern (DOUBLE_COLON sigma)* // was left rec
    { pin=1 }

atPattern ::= pVar AT atPattern
                | listPattern
listPattern ::= matcherPattern (COLON listPattern)?
matcherPattern ::= pVar TILDA REGEX
                    | pconApp
pconApp ::= strictPattern+
strictPattern ::= EXLAMATION_MARK? pTerm
pTerm ::= dataNameUsage LEFT_BRACE patternFields? RIGHT_BRACE
            | dataNameUsage
            | pVar
            | literal
            | unit
            | emptyList
            | LEFT_BRACKET pattern (COMMA pattern)* RIGHT_BRACKET
            | LEFT_PAREN pattern (COMMA pattern)* RIGHT_PAREN
pVar ::= param
            | UNDERSCORE
patternFields ::= patternField (COMMA patternField)*
patternField ::= param (EQUAL pattern)? // TODO I'm not sure about this

/* Declarations and Bindings */
// TODO modifiers
program ::= PROTECTED_MODIFIER? (PACKAGE | MODULE) packageName inlineRule? WHERE VIRTUAL_OPEN_SECTION body {
    pin=1
    implements="com.plugin.frege.psi.FregePsiClassHolder"
    mixin="com.plugin.frege.psi.mixin.FregeProgramMixin"
}

packagePrefix ::= ((packageVarid | qConId) DOT)*
packageName ::= packagePrefix packageClassName
private packageVarid ::= qualifier? qualifier? (weakVarid | DATA | IMPORT | NATIVE | PACKAGE | MODULE | TYPE)

packageClassName ::= qConId {
    implements="com.plugin.frege.psi.FregePsiClass"
    mixin="com.plugin.frege.psi.mixin.FregePackageClassNameMixin"
}

qName ::= qVarId | qLexOp
inlineRule ::= strongInline LEFT_PAREN qName (COMMA qName)* RIGHT_PAREN

body ::= topDecl (VIRTUAL_END_DECL topDecl)* {
    implements="com.plugin.frege.psi.FregeScopeElement"
    mixin="com.plugin.frege.psi.mixin.FregeBodyMixin"
}

topDecl ::= !<<eof>> (
              fixity
            | importDcl
            | accessModifier? typeDcl
            | accessModifier? dataDcl
            | accessModifier? classDcl
            | accessModifier? instDcl
            | accessModifier? deriveDcl
            | decl)
    { pin=1 recoverWhile=declRecover }

accessModifier ::= PUBLIC_MODIFIER | PROTECTED_MODIFIER | PRIVATE_MODIFIER

decl ::= accessModifier? (annotation | binding | nativeFun) {
    implements="com.plugin.frege.psi.FregeSubprogramsHolder"
}

/* Syntax of Types */
sigma ::= (FORALL tyVar (tyVar)* DOT)? chro
chro ::= (constraints DOUBLE_RIGHT_ARROW)? rho
rho ::= LEFT_PAREN sigma RIGHT_PAREN RIGHT_ARROW rho
        | tyApp RIGHT_ARROW rho
        | tyApp
constraints ::= constraint
                | LEFT_PAREN constraint (COMMA constraint)* COMMA? RIGHT_PAREN
constraint ::= className tyApp+
typeRule ::= tyApp (RIGHT_ARROW typeRule)* // was left rec
tyApp ::= simpleType+ // was left rec

simpleType ::= tyVar
                | tyCon
                | LEFT_PAREN typeRule RIGHT_PAREN
                | LEFT_PAREN typeRule COMMA typeRule (COMMA typeRule)* RIGHT_PAREN
                | LEFT_BRACKET typeRule RIGHT_BRACKET
                | LEFT_PAREN typeRule VERT_BAR typeRule (VERT_BAR typeRule)* RIGHT_PAREN
tyVar ::= weakVarid
            | LEFT_PAREN weakVarid DOUBLE_COLON kind RIGHT_PAREN
tyCon ::= qConId
            | emptyList
            | unit
            | tupleConstructor
            | RIGHT_ARROW
className ::= qConId
kind ::= simpleKind
            | simpleKind RIGHT_ARROW kind
simpleKind ::= STAR
                | LEFT_PAREN kind RIGHT_PAREN



/* Algebraic Data type Declaration */
dataDcl ::= (dataDclConstructors | dataDclNative) deriveDcl?
    { pin=1 }

dataDclConstructors ::= ABSTRACT? DATA dataNameConstructor tyVar* EQUAL constructors whereSection?
    { pin=6 }
dataDclNative ::= DATA dataNameNative tyVar* EQUAL (strongMutable|strongPure)? NATIVE nativeName whereSection? {
    pin=6
    implements="com.plugin.frege.psi.FregePsiClassHolder"
    mixin="com.plugin.frege.psi.mixin.FregeDataDclNativeMixin"
}

dataNameConstructor ::= CONID

dataNameNative ::= CONID {
    implements="com.plugin.frege.psi.FregePsiClass"
    mixin="com.plugin.frege.psi.mixin.FregeDataNameNativeMixin"
}
dataNameUsage ::= CONID {
    implements="com.plugin.frege.psi.FregeCompositeElement"
    mixin="com.plugin.frege.psi.mixin.FregeDataNameUsageMixin"
}

nativeName ::= (weakVarid | CONID) (DOT (weakVarid | CONID))* {
    implements="com.plugin.frege.psi.FregeCompositeElement"
    mixin="com.plugin.frege.psi.mixin.FregeNativeNameMixin"
}

constructors ::= constructor (VERT_BAR constructor)*

constructor ::= PRIVATE? (EXLAMATION_MARK? dataNameUsage) (LEFT_BRACE labels DOUBLE_COLON sigma (COMMA labels DOUBLE_COLON sigma)* RIGHT_BRACE | (simpleType | bracedConstructor)*)
bracedConstructor ::= LEFT_PAREN (bracedConstructor | constructor) RIGHT_PAREN

labels ::= label (COMMA label)*
label ::= EXLAMATION_MARK? weakVarid

typeDcl ::= TYPE dataNameType (tyVar)* EQUAL sigma
    { pin=1 }

dataNameType ::= CONID

/* Class Declarations */
classDcl ::= (CLASS | INTERFACE) constraints ( DOUBLE_RIGHT_ARROW CONID classVar)?  whereSection?
    { pin=1 }

classVar ::= tyVar

/* Instance Declarations */
instDcl ::= INSTANCE (constraints DOUBLE_RIGHT_ARROW)? className typeRule whereSection?
    { pin=1 }

/* Derived Instances */
deriveDcl ::= DERIVE className (constraints DOUBLE_RIGHT_ARROW)? typeRule
    { pin=1 }

/* fake function name rule for highlighting */
functionName ::= weakVarid {
    mixin="com.plugin.frege.psi.mixin.FregeFunctionNameMixin"
    implements="com.plugin.frege.psi.FregePsiMethod"
}

/*  Type Annotations */
annotation ::= annoItem (COMMA annoItem)* DOUBLE_COLON sigma
    { pin=3 }
annoItem ::= functionName | LEFT_PAREN symOp RIGHT_PAREN | UNOP

/*  Function and Pattern Bindings */
binding ::= lhs rhs
lhs ::= funLhs | pattern
funLhs ::= pconApp lexOp pconApp
            | (functionName | LEFT_PAREN symOp RIGHT_PAREN) strictPattern* // TODO UNOP?
rhs ::= (EQUAL expr | guardedExs) whereSection?
    { pin=1 }

/* Native Declaration */
nativeFun ::= strongPure? NATIVE nativeAnnoItem javaItem? DOUBLE_COLON sigma (VERT_BAR sigma)* throwsRule?
    { pin=2 }
javaItem ::= nativeName | unOp | symOp | STRING
throwsRule ::= THROWS typeRule (COMMA typeRule)*
nativeAnnoItem ::= nativeFunctionName | LEFT_PAREN symOp RIGHT_PAREN | UNOP
nativeFunctionName ::= weakVarid {
    implements="com.plugin.frege.psi.FregeCompositeElement"
    mixin="com.plugin.frege.psi.mixin.FregeNativeFunctionNameMixin"
}

/* Importing Packages */
importDcl ::= IMPORT importPackageName (strongAs? nameSpace)? PUBLIC_MODIFIER? importList?
    { pin=1 }

importPackageName ::= packagePrefix importName
importName ::= qConId
importList ::= strongHiding? LEFT_PAREN (importSpec (COMMA importSpec)*)? RIGHT_PAREN
importSpec ::= PUBLIC_MODIFIER? importItem alias?
importItem ::= weakVarid
                | CONID members?
                | symOp
                | LEFT_PAREN symOp RIGHT_PAREN
                | BACK_QUOTE symOp BACK_QUOTE
                | CONID DOT (weakVarid | CONID | symOp)
alias ::= weakVarid | CONID | symOp
members ::= LEFT_PAREN (memSpec (COMMA memSpec)*)? RIGHT_PAREN
memSpec ::= PUBLIC_MODIFIER? member alias?
member ::= weakVarid | symOp | CONID
nameSpace ::= CONID


todo ::= NEW_LINE | SYMBOL_OPERATOR | INTEGER | SLASH | STAR | TILDA | HASH | AT | COLON | DASH | FLOAT | REGEX | CHAR | WORD_OPERATOR | CASE | TRUE | PURE
            | CLASS | FALSE | INFIX | DERIVE | THROWS | NATIVE | INFIXL | INFIXR | IMPORT | MODULE | PUBLIC_MODIFIER | PLUS | LESS | GREATER
            | MUTABLE | INSTANCE | INTERFACE | PROTECTED_MODIFIER | OF | STRING | UNDERSCORE | QUESTION_MARK | DO | LEFT_ARROW | SLASH | LINE_COMMENT | BLOCK_COMMENT
            | DEFAULT | FOREIGN | NEWTYPE | DERIVING